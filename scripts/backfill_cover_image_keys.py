#!/usr/bin/env python3
"""
Backfill novels.cover_image_key based on files already present in novels/uploads/covers.

This is intentionally NOT dependent on newmaga-parser. It only links existing cover files
to existing novels by matching filename UUID to novels.id.

Two modes:
  1) emit SQL (default, no deps):
     python3 scripts/backfill_cover_image_keys.py --uploads /home/fsociety/novels/uploads > backfill_covers.sql
     # then apply via psql (e.g. inside docker postgres container)

  2) apply directly (requires psycopg[binary]):
     python3 scripts/backfill_cover_image_keys.py \
       --uploads /home/fsociety/novels/uploads \
       --pg "postgres://novels:novels_dev_password@localhost:5432/novels?sslmode=disable" \
       --apply
"""

from __future__ import annotations

import argparse
import os
import re
import sys
from dataclasses import dataclass


UUID_RE = re.compile(
    r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
)


def connect_pg(pg_dsn: str):
    try:
        import psycopg
    except Exception as e:
        raise RuntimeError(
            "psycopg is required. Install with: python3 -m pip install 'psycopg[binary]'"
        ) from e
    return psycopg.connect(pg_dsn)


@dataclass(frozen=True)
class CoverFile:
    novel_id: str
    rel_key: str  # e.g. covers/<uuid>.jpg


def scan_covers(uploads_dir: str) -> list[CoverFile]:
    covers_dir = os.path.join(uploads_dir, "covers")
    if not os.path.isdir(covers_dir):
        return []

    out: list[CoverFile] = []
    for name in os.listdir(covers_dir):
        full = os.path.join(covers_dir, name)
        if not os.path.isfile(full):
            continue
        base, ext = os.path.splitext(name)
        if ext.lower() not in (".jpg", ".jpeg", ".png", ".webp"):
            continue
        if not UUID_RE.match(base):
            continue
        out.append(CoverFile(novel_id=base.lower(), rel_key=f"covers/{name}"))
    return out


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--uploads", required=True, help="Path to novels uploads dir (contains covers/...)")
    ap.add_argument("--pg", help="Postgres DSN (required with --apply)")
    ap.add_argument("--apply", action="store_true", help="Apply updates directly using psycopg")
    args = ap.parse_args(argv)

    covers = scan_covers(args.uploads)
    if not covers:
        print(f"No cover files found under: {os.path.join(args.uploads, 'covers')}", file=sys.stderr)
        return 2

    if not args.apply:
        # Emit SQL so the user can apply it with any psql (no Python deps required).
        print("-- Generated by scripts/backfill_cover_image_keys.py")
        print("BEGIN;")
        for c in covers:
            # Only fill missing keys (do not overwrite existing)
            print(
                "UPDATE novels "
                f"SET cover_image_key = '{c.rel_key}' "
                f"WHERE id = '{c.novel_id}'::uuid "
                "AND (cover_image_key IS NULL OR cover_image_key = '');"
            )
        print("COMMIT;")
        return 0

    if not args.pg:
        print("--pg is required with --apply", file=sys.stderr)
        return 2

    pg = connect_pg(args.pg)
    pg.autocommit = False

    updated = 0
    skipped = 0
    try:
        with pg.cursor() as cur:
            for c in covers:
                cur.execute(
                    """
                    UPDATE novels
                    SET cover_image_key = %s
                    WHERE id = %s::uuid
                      AND (cover_image_key IS NULL OR cover_image_key = '')
                    """,
                    (c.rel_key, c.novel_id),
                )
                if cur.rowcount:
                    updated += cur.rowcount
                else:
                    skipped += 1
        pg.commit()
    finally:
        try:
            pg.close()
        except Exception:
            pass

    print(f"Done. updated={updated} skipped={skipped} (skipped means novel not found or already had cover_image_key)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))

